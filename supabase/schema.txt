-- ═══════════════════════════════════════════════════════════
-- DENTIGUIDE — Database Schema
-- Run this in Supabase SQL Editor after creating your project
-- ═══════════════════════════════════════════════════════════

-- Settings: company info, signatory, PRRC (one row per user)
CREATE TABLE settings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  company_name TEXT DEFAULT 'Dentiguide GmbH',
  street TEXT DEFAULT 'Kanalweg 2c',
  postal TEXT DEFAULT '48529',
  city TEXT DEFAULT 'Nordhorn',
  country TEXT DEFAULT 'Germany',
  phone TEXT DEFAULT '',
  email TEXT DEFAULT '',
  site2_name TEXT DEFAULT '',
  site2_address TEXT DEFAULT '',
  prrc_name TEXT DEFAULT 'A. Alhelwani',
  prrc_qual TEXT DEFAULT 'DDS · MSc Periodontics · MSc Adv. Medical Imaging',
  signer_name TEXT DEFAULT 'A. Alhelwani',
  signer_title TEXT DEFAULT 'Managing Director',
  signer_credentials TEXT DEFAULT 'DDS · MSc Periodontics · MSc Adv. Medical Imaging',
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now(),
  UNIQUE(user_id)
);

-- Clinics / Prescribers
CREATE TABLE clinics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  big_register TEXT DEFAULT '',
  practice TEXT DEFAULT '',
  address TEXT DEFAULT '',
  phone TEXT DEFAULT '',
  email TEXT DEFAULT '',
  notes TEXT DEFAULT '',
  status TEXT DEFAULT 'active' CHECK (status IN ('active', 'trial', 'prospect', 'inactive')),
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- Materials library
CREATE TABLE materials (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  manufacturer TEXT DEFAULT '',
  type TEXT DEFAULT '',
  ce_class TEXT DEFAULT '',
  ce_cert TEXT DEFAULT '',
  iso_10993 TEXT DEFAULT '',
  biocompat TEXT DEFAULT '',
  ifu TEXT DEFAULT '',
  is_default BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT now()
);

-- MDR Documents (each form submission)
CREATE TABLE documents (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  doc_ref TEXT NOT NULL,
  doc_type TEXT NOT NULL CHECK (doc_type IN ('mdr_statement', 'delivery_note')),
  clinic_id UUID REFERENCES clinics(id) ON DELETE SET NULL,
  -- Snapshot of all form data at time of creation
  form_data JSONB NOT NULL DEFAULT '{}',
  -- Key fields for quick filtering
  patient_code TEXT DEFAULT '',
  device_types TEXT[] DEFAULT '{}',
  teeth TEXT DEFAULT '',
  status TEXT DEFAULT 'draft' CHECK (status IN ('draft', 'final', 'voided')),
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- Document counter (for sequential CMD-YYYY-NNNN refs)
CREATE TABLE doc_counters (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  year INT NOT NULL,
  counter INT NOT NULL DEFAULT 0,
  UNIQUE(user_id, year)
);

-- ═══════════════════════════════════════════════════════════
-- Row Level Security (RLS) — users can only see their own data
-- ═══════════════════════════════════════════════════════════

ALTER TABLE settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE clinics ENABLE ROW LEVEL SECURITY;
ALTER TABLE materials ENABLE ROW LEVEL SECURITY;
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;
ALTER TABLE doc_counters ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users see own settings" ON settings FOR ALL USING (auth.uid() = user_id);
CREATE POLICY "Users see own clinics" ON clinics FOR ALL USING (auth.uid() = user_id);
CREATE POLICY "Users see own materials" ON materials FOR ALL USING (auth.uid() = user_id);
CREATE POLICY "Users see own documents" ON documents FOR ALL USING (auth.uid() = user_id);
CREATE POLICY "Users see own counters" ON doc_counters FOR ALL USING (auth.uid() = user_id);

-- ═══════════════════════════════════════════════════════════
-- Function: get next document reference
-- ═══════════════════════════════════════════════════════════

CREATE OR REPLACE FUNCTION next_doc_ref(p_user_id UUID)
RETURNS TEXT AS $$
DECLARE
  v_year INT := EXTRACT(YEAR FROM now());
  v_counter INT;
BEGIN
  INSERT INTO doc_counters (user_id, year, counter)
  VALUES (p_user_id, v_year, 1)
  ON CONFLICT (user_id, year) DO UPDATE SET counter = doc_counters.counter + 1
  RETURNING counter INTO v_counter;
  RETURN 'CMD-' || v_year || '-' || lpad(v_counter::text, 4, '0');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
